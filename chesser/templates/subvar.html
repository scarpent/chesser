{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chessboard</title>
    <link href="{% static 'chessground/chessground.base.css' %}" rel="stylesheet">
    <link href="{% static 'chessground/chessground.brown.css' %}" rel="stylesheet">
    <link href="{% static 'chessground/chessground.fantasy.css' %}" rel="stylesheet">
    <style>
        #board {
            width: 100%; /* Responsive board */
            max-width: 450px;
            height: 450px;
            margin: 0 auto;
        }
        .move-nav {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        .move-nav button {
            margin: 0 10px;
        }
        .move-list {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }
        .move-list a {
            margin: 0 5px;
            cursor: pointer;
        }
        .variation {
            margin-left: 20px;
        }
    </style>
</head>
<body x-data="chessApp()" x-init="initChessground()" @keydown.left="prevMove()" @keydown.right="nextMove()">

    <div id="board"></div>
    <div x-text="status" style="margin-top: 20px;"></div>

    <div class="move-nav">
        <button @click="prevMove()">⬅️</button>
        <button @click="nextMove()">➡️</button>
    </div>

    <div class="move-list">
        <template x-for="(move, index) in currentMoves" :key="index">
            <a @click="goToMove(index)" x-text="formatMove(index, move)"></a>
        </template>
    </div>

    <div class="move-tree">
        <template x-for="(move, index) in moveTree.mainline" :key="index">
            <div>
                <a @click="goToMove(index)" x-text="formatMove(index, move.move)"></a>
                <div class="variation" x-show="move.variations.length > 0">
                    <template x-for="(variation, vIndex) in move.variations" :key="vIndex">
                        <div>
                            <span>(</span>
                            <template x-for="(vMove, vMoveIndex) in variation.mainline" :key="vMoveIndex">
                                <a @click="goToVariationMove(index, vMoveIndex, vIndex)" x-text="formatMove(vMoveIndex, vMove.move)"></a>
                            </template>
                            <span>)</span>
                        </div>
                    </template>
                </div>
            </div>
        </template>
    </div>

    <!-- Load Chessground and Chess.js as ES modules -->
    <script type="module">
        import { Chessground } from 'https://cdn.jsdelivr.net/npm/chessground@9.1.1/dist/chessground.min.js';
        import { Chess } from 'https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/esm/chess.js';
        window.Chessground = Chessground;
        window.Chess = Chess;
    </script>

    <!-- Define chessApp BEFORE Alpine.js initializes -->
    <script>
        function chessApp() {
            return {
                board: null,
                chess: null,
                status: 'Ready',
                moves: [],
                currentMoveIndex: 0,
                currentMoves: [],
                moveTree: null,
                initChessground() {
                    const boardElement = document.getElementById('board');
                    if (boardElement && window.Chessground && window.Chess) {
                        this.chess = new window.Chess();
                        this.board = window.Chessground(boardElement, {
                            viewOnly: false,
                            draggable: true,
                            highlight: {
                                lastMove: true,
                                check: true
                            },
                            orientation: 'white',
                            fen: 'start', // Initial position
                            movable: {
                                color: 'both', // Allow both white and black to move
                                free: false, // Only legal moves
                                dests: this.toDests(),
                                events: {
                                    after: this.handleMove.bind(this)
                                }
                            }
                        });
                        this.status = 'Chessboard Loaded!';
                        this.parsePGN("1. e4 e5 (1... c5 2. c3) 2. Nf3 Nc6 3. d4 (3. Nc3) 3... exd4");
                        this.currentMoves = this.moveTree.mainline.map(move => move.move);
                    } else {
                        console.error('Chessground or Chess.js failed to load');
                    }
                },
                toDests() {
                    const dests = new Map();
                    const squares = this.chess.SQUARES || this.chess.board().flatMap(row => row.map(square => square ? square.square : null)).filter(Boolean);
                    squares.forEach(s => {
                        const ms = this.chess.moves({ square: s, verbose: true });
                        if (ms.length) dests.set(s, ms.map(m => m.to));
                    });
                    return dests;
                },
                handleMove(orig, dest) {
                    const move = this.chess.move({ from: orig, to: dest });
                    if (move) {
                        this.status = `Moved from ${orig} to ${dest}`;
                        this.board.set({
                            fen: this.chess.fen(),
                            movable: {
                                dests: this.toDests()
                            }
                        });
                    } else {
                        this.status = `Illegal move from ${orig} to ${dest}`;
                    }
                },
                parsePGN(pgn) {
                    const moveTree = { mainline: [], variations: [] };
                    const stack = [moveTree];
                    const tokens = pgn.split(/\s+/);
                    let current = moveTree;

                    tokens.forEach(token => {
                        if (token === '(') {
                            const newVariation = { mainline: [], variations: [] };
                            current.variations.push(newVariation);
                            stack.push(newVariation);
                            current = newVariation;
                        } else if (token === ')') {
                            stack.pop();
                            current = stack[stack.length - 1];
                        } else if (!token.includes('.')) {
                            current.mainline.push({ move: token, variations: [] });
                        }
                    });

                    this.moveTree = moveTree;
                },
                goToMove(index) {
                    this.chess.reset();
                    for (let i = 0; i <= index; i++) {
                        this.chess.move(this.currentMoves[i]);
                    }
                    this.board.set({
                        fen: this.chess.fen()
                    });
                    this.currentMoveIndex = index;
                    this.status = `Move ${index + 1}: ${this.currentMoves[index]}`;
                },
                goToVariationMove(mainIndex, varIndex, varTreeIndex) {
                    this.chess.reset();
                    for (let i = 0; i <= mainIndex; i++) {
                        this.chess.move(this.moveTree.mainline[i].move);
                    }
                    for (let j = 0; j <= varIndex; j++) {
                        this.chess.move(this.moveTree.mainline[mainIndex].variations[varTreeIndex].mainline[j].move);
                    }
                    this.board.set({
                        fen: this.chess.fen()
                    });
                    this.currentMoveIndex = mainIndex + varIndex + 1;
                    this.status = `Variation Move ${varIndex + 1}: ${this.moveTree.mainline[mainIndex].variations[varTreeIndex].mainline[varIndex].move}`;
                },
                prevMove() {
                    if (this.currentMoveIndex > 0) {
                        this.goToMove(this.currentMoveIndex - 1);
                    }
                },
                nextMove() {
                    if (this.currentMoveIndex < this.currentMoves.length - 1) {
                        this.goToMove(this.currentMoveIndex + 1);
                    }
                },
                formatMove(index, move) {
                    return `${Math.floor(index / 2) + 1}.${index % 2 === 0 ? '' : '...'} ${move}`;
                }
            };
        }
    </script>

    <!-- Load Alpine.js LAST -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.5/dist/cdn.min.js"></script>

</body>
</html>
